Exposed  = mean(Exposed,  na.rm = TRUE),
Believer = mean(Believer, na.rm = TRUE),
.groups  = "drop"
)
# 1b. Compute instantaneous speeds & smooth
rq3_rates_day <- rq3_mean_day %>%
arrange(Disinformant, valence, pop_ratio, Time) %>%
group_by(Disinformant, valence, pop_ratio) %>%
mutate(
dt_mins    = as.numeric(difftime(Time, lag(Time), units = "mins")),
dE         = Exposed  - lag(Exposed),
dB         = Believer - lag(Believer),
speed_E2B  = - dE / dt_mins,      # convert per‐minute → per‐day
speed_B2R  = - dB / dt_mins,
smooth_E2B = rollapply(speed_E2B, 5, mean, partial = TRUE, align = "center"),
smooth_B2R = rollapply(speed_B2R, 5, mean, partial = TRUE, align = "center")
) %>%
filter(!is.na(dt_mins) & dt_mins > 0) %>%
ungroup()
# 1c. Pivot to long form for ggplot
rq3_plot_day <- rq3_rates_day %>%
select(Disinformant, valence, pop_ratio, Time, smooth_E2B, smooth_B2R) %>%
pivot_longer(
cols      = c(smooth_E2B, smooth_B2R),
names_to  = "Transition",
values_to = "Speed"
) %>%
mutate(
pop_ratio  = factor(pop_ratio),
Transition = recode(Transition,
smooth_E2B = "E → B (infection)",
smooth_B2R = "B → R (recovery)"
)
)
# 1d. Plot daily dynamics with facets by Disinformant × pop_ratio
p_day <- ggplot(rq3_plot_day,
aes(x = Time, y = Speed,
colour = factor(valence), group = valence)) +
#geom_line(size = 0.3, alpha = 0.6) +
geom_smooth(method = "loess", se = FALSE, size = 0.5) +
scale_colour_manual(
name   = expression(valence),
values = c("1"="orange","5"="green","10"="blue")
) +
facet_grid(
Transition ~ pop_ratio,
scales   = "fixed",
labeller = label_both
) +
theme_minimal(base_size = 8) +
theme(
legend.position   = "bottom",
strip.text.y.left = element_text(angle = 0),
axis.text.x       = element_text(angle = 45, hjust = 1)
) +
labs(
title = "RQ3 – Daily Dynamics",
x     = "Simulation time",
y     = "Speed"
)
# -------------------------
# 2. WEEKLY DYNAMICS PIPELINE
# -------------------------
# 2a. Compute DateTime from Day + Time, and mean across runs
rq3_mean_week <- rq3_raw2 %>%
mutate(
DateTime = origin + days(Day - 1) + Time
) %>%
group_by(Disinformant, valence, pop_ratio, DateTime) %>%
summarise(
Exposed  = mean(Exposed,  na.rm = TRUE),
Believer = mean(Believer, na.rm = TRUE),
.groups  = "drop"
)
# 2b. Compute speeds in agents/day & smooth
rq3_rates_week <- rq3_mean_week %>%
arrange(Disinformant, valence, pop_ratio, DateTime) %>%
group_by(Disinformant, valence, pop_ratio) %>%
mutate(
dt_days    = as.numeric(difftime(DateTime, lag(DateTime), units = "mins")),
dE         = Exposed  - lag(Exposed),
dB         = Believer - lag(Believer),
speed_E2B  = - dE / dt_days,     # agents per day
speed_B2R  = - dB / dt_days,
smooth_E2B = rollapply(speed_E2B, 5, mean, partial = TRUE, align = "center"),
smooth_B2R = rollapply(speed_B2R, 5, mean, partial = TRUE, align = "center")
) %>%
filter(!is.na(dt_days) & dt_days > 0) %>%
ungroup()
# 2c. Pivot to long form
rq3_plot_week <- rq3_rates_week %>%
select(Disinformant, valence, pop_ratio, DateTime, smooth_E2B, smooth_B2R) %>%
pivot_longer(
cols      = c(smooth_E2B, smooth_B2R),
names_to  = "Transition",
values_to = "Speed"
) %>%
mutate(
pop_ratio  = factor(pop_ratio),
Transition = recode(Transition,
smooth_E2B = "E → B (infection)",
smooth_B2R = "B → R (recovery)"
)
)
# 2d. Plot weekly dynamics with same facet structure
p_week <- ggplot(rq3_plot_week,
aes(x = DateTime, y = Speed,
colour = factor(valence), group = valence)) +
#geom_line(size = 0.3, alpha = 0.6) +
geom_smooth(method = "loess", se = FALSE, size = 0.5) +
scale_colour_manual(
name   = expression(valence),
values = c("1"="orange","5"="green","10"="blue")
) +
facet_grid(
Transition ~ pop_ratio,
scales   = "fixed",
labeller = label_both
) +
scale_x_datetime(
date_breaks = "2 day",
labels      = function(x) day(x)
) +
theme_minimal(base_size = 8) +
theme(
legend.position   = "bottom",
strip.text.y.left = element_text(angle = 0),
axis.text.x       = element_text(angle = 45, hjust = 1)
) +
labs(
title = "RQ3 – Weekly Dynamics",
x     = "Date",
y     = "Speed"
)
p_day
p_week
knitr::opts_chunk$set(echo = TRUE)
# Install pacman first (only once):
install.packages("pacman")
# Load and install packages:
pacman::p_load(ggplot2, dplyr, tidyr) #So it installs the library if needed + imports it in one step.
# Adding values
my_string <- "Hello there"
my_integer <- 13
my_boolean <- TRUE
my_float <- 4.54
# Testing the class
class(my_string)
# Adding values
my_string <- "Hello there"
my_integer <- 13
my_boolean <- TRUE
my_float <- 4.54
# Testing the class
class(my_integer)
# Testing the class
class(my_boolean)
# Adding values
my_string <- "Hello there"
my_integer <- 13
my_boolean <- TRUE
my_float <- 4.54
# Testing the class
class(my_float)
my_list <- list(1, "two", "million", 4.5)
my_namedlist <- list(name = "Alice", age = 30, city = "New York")
my_vector <- c(1, 2, 3, 4, 5)
# Vectors
numbers <- c(10, 20, 30, 40)
numbers[1]       # Access the first element → 10
numbers[c(2, 4)] # Access the 2nd and 4th elements → 20, 40
#When passing multiple numbers in r we usually use a vector like here c() to specify the numbers we need.
# Lists / named lists
my_list <- list(name = "Johanne", age = 25, scores = c(90, 85, 88))
my_list[1]      # Returns a sublist containing the first element → list(name = "Johanne")
my_list[[1]]    # Returns the actual element → "Johanne"
my_list$age    # Access by age → 25
my_list[[3]]    # Access the scores vector → c(90, 85, 88)
# Access the 2nd element in my_list
my_list[[2]]
# Access the age  in my_namedlist
my_namedlist$age
# Access the 2nd element in my_list
my_list[[2]]
# Access the age  in my_namedlist
my_namedlist$age
# Access the 3rd element in my_vector
my_vector[3]
# Access the 2nd element in my_list
my_list[[2]]
# Access the age  in my_namedlist
my_namedlist$city
# Access the 3rd element in my_vector
my_vector[3]
my_list <- list(1, "two", "million", 4.5)
my_namedlist <- list(name = "Réka", age = 22, city = "Aarhus")
my_vector <- c(1, 2, 3, 4, 5)
# Vectors
numbers <- c(10, 20, 30, 40)
numbers[1]       # Access the first element → 10
numbers[c(2, 4)] # Access the 2nd and 4th elements → 20, 40
#When passing multiple numbers in r we usually use a vector like here c() to specify the numbers we need.
# Lists / named lists
my_list <- list(name = "Johanne", age = 25, scores = c(90, 85, 88))
my_list[1]      # Returns a sublist containing the first element → list(name = "Johanne")
my_list[[1]]    # Returns the actual element → "Johanne"
my_list$age    # Access by age → 25
my_list[[3]]    # Access the scores vector → c(90, 85, 88)
# Access the 2nd element in my_list
my_list[[2]]
# Access the age  in my_namedlist
my_namedlist$city
# Access the 3rd element in my_vector
my_vector[3]
# The if statement
x <- 5
if (x > 0) {
print("x is positive")
}
# The else statement
x <- -3
if (x > 0) {
print("x is positive")
} else {  # Here there is a new set of curly brackets because there is a new condition
print("x is not positive")
}
# The else if (elif) statement
x <- 0
if (x > 0) {
print("x is positive")
} else if (x < 0) {
print("x is negative")
} else {
print("x is zero")
}
x <- 5
if (x > 5) {
print("x is greater than 5")}
else if (x == 5) {
x <- 5
if (x > 5) {
print("x is greater than 5")
} else if (x == 5) {
print("x is equal to 5")
} else {
print("x is less than 5")
}
# a for loop
for (i in 1:5) {
print(i)
}
x <- 1
while (x <= 5) {
print(x)
x <- x + 1
}
fruits <- c("apple", "banana", "cherry")
for (fruit in fruits) {
print(fruit)
}
add_numbers <- function(a, b) {
sum <- a + b
return(sum)
}
add_numbers(3, 5)
knitr::opts_chunk$set(
echo = TRUE,          # show code
comment = "",         # removes the leading '#'
message = FALSE,      # suppress package load messages
warning = FALSE,      # suppress warnings
fig.align = "left", # center figures
fig.width = 7,        # control figure width
fig.height = 4     # control figure height
)
pacman::p_load(ggplot2, dplyr, tidyr, dslabs, car, pastecs)
df <- as.data.frame(divorce_margarine)
head(df)
#normality checks
ggplot(df, aes(x = divorce_rate_maine)) +
geom_histogram(aes(y = ..density..), bins = 15,
fill = "palevioletred", color = "black") +
geom_density(color = "red", linewidth = 1) +
labs(title = "Distribution of divorce rate in Maine",
x = "Divorce Rate", y = "Density") +
theme_minimal()
ggplot(df, aes(x = margarine_consumption_per_capita)) +
geom_histogram(aes(y = ..density..), bins = 15,
fill = "goldenrod1", color = "black") +
geom_density(color = "red", linewidth = 1) +
labs(title = "Distribution of margarine consumption",
x = "Margarine Consumption", y = "Density") +
theme_minimal()
ggplot(df, aes(sample = divorce_rate_maine)) +
stat_qq(color = "palevioletred") +
stat_qq_line(color = "red") +
labs(title = "Q-Q Plot: Divorce Rate Maine") +
theme_minimal()
ggplot(df, aes(sample = margarine_consumption_per_capita)) +
stat_qq(color = "goldenrod1") +
stat_qq_line(color = "red") +
labs(title = "Q-Q Plot: Margarine Consumption") +
theme_minimal()
shapiro.test(df$divorce_rate_maine)
shapiro.test(df$margarine_consumption_per_capita)
round(pastecs::stat.desc(cbind(df$divorce_rate_maine,
df$margarine_consumption_per_capita),
basic = FALSE, norm = TRUE), digits = 2)
cor.test(df$divorce_rate_maine,
df$margarine_consumption_per_capita,
method = "pearson")
#visualise both variables on one plot by year
ggplot(df, aes(x = year)) +
geom_line(aes(y = scale(divorce_rate_maine),
color = "Divorce Rate in Maine"), linewidth = 1) +
geom_line(aes(y = scale(margarine_consumption_per_capita),
color = "Margarine Consumption per Capita"), linewidth = 1) +
scale_x_continuous(breaks = 2000:2009) +
scale_color_manual(values = c("Divorce Rate in Maine" = "palevioletred",
"Margarine Consumption per Capita" = "goldenrod1")) +
labs(
title = "Divorce Rate and Margarine Consumption in Maine (2000–2009)",
subtitle = "Standardized (z-score) values for comparison",
x = "Year", y = "Standardized Value (z)"
) +
theme_minimal() +
theme(legend.title = element_blank(), legend.position = "top")
df2 <- as.data.frame(GSSvocab)
#subsetting
df2 <- df2 %>%
filter(year == 1978) %>%
drop_na()
head(df2)
#checking types of variables
str(df2)
knitr::opts_chunk$set(echo = TRUE)
# Install pacman first (only once):
install.packages("pacman")
# Load and install packages:
pacman::p_load(ggplot2, dplyr, tidyr, broom, performance, see, car)
install.packages("pacman")
df_states <- as.data.frame(state.x77)
df_states$Region <- state.region
head(df_states)
ggplot(df_states, aes(x = Income, y = `Life Exp`)) +
geom_point() +
theme_minimal() +
labs(title = "Relationship between Income and Illiteracy", x = "Income (per person in 1974)", y = "Life expectancy (in years)")
```{r}
summary(model_income)
model_income <- lm(`Life Exp` ~ Income, data = df_states)
summary(model_income)
model_income_region <- lm(`Life Exp` ~ Income + Region, data = df_states)
summary(model_income_region)
df_states <- as.data.frame(state.x77)
df_states$Region <- state.region
head(df_states)
View(df_states)
model_interaction <- lm(`Life Exp` ~ Income * Region, data = df_states)
summary(model_interaction)
# Plot the interaction
ggplot(df_states, aes(x = Income, y = `Life Exp`, color = Region)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE) +
theme_minimal()
# 1. Linearity
check_model(model_interaction, check = "linearity")
# 2. Homoscedasticity (constant variance)
check_model(model_interaction, check = "homogeneity")
# 3. Normality of residuals
check_model(model_interaction, check = "normality")
# 4. Outliers / influential points
check_model(model_interaction, check = "outliers")
# 5. Multicolinearity
vif(model_interaction, type = "predictor")
# 1. Linearity
check_model(model_interaction, check = "linearity")
# 2. Homoscedasticity (constant variance)
check_model(model_interaction, check = "homogeneity")
# 3. Normality of residuals
check_model(model_interaction, check = "normality")
# 4. Outliers / influential points
check_model(model_interaction, check = "outliers")
# 5. Multicolinearity
vif(model_interaction, type = "predictor")
library(performance)
# Load and install packages:
pacman::p_load(ggplot2, dplyr, tidyr, broom, performance, see, car)
# 1. Linearity
check_model(model_interaction, check = "linearity")
# 2. Homoscedasticity (constant variance)
check_model(model_interaction, check = "homogeneity")
# 3. Normality of residuals
check_model(model_interaction, check = "normality")
# 4. Outliers / influential points
check_model(model_interaction, check = "outliers")
# 5. Multicolinearity
vif(model_interaction, type = "predictor")
# 1. Linearity
check_model(model_interaction, check = "linearity")
# 2. Homoscedasticity (constant variance)
check_model(model_interaction, check = "homogeneity")
# 3. Normality of residuals
check_model(model_interaction, check = "normality")
# 4. Outliers / influential points
check_model(model_interaction, check = "outliers")
# 5. Multicolinearity
vif(model_interaction, type = "predictor")
# Install pacman first (only once):
install.packages("pacman")
# Load and install packages:
pacman::p_load(ggplot2, dplyr, tidyr, broom, performance, see)
# 1. Linearity
check_model(model_interaction, check = "linearity")
knitr::opts_chunk$set(echo = TRUE)
# Install pacman first (only once):
install.packages("pacman")
# Load and install packages:
pacman::p_load(ggplot2, dplyr, tidyr, broom, performance, see)
# 1. Linearity
check_model(model_interaction, check = "linearity")
# 2. Homoscedasticity (constant variance)
check_model(model_interaction, check = "homogeneity")
# 3. Normality of residuals
check_model(model_interaction, check = "normality")
# 4. Outliers / influential points
check_model(model_interaction, check = "outliers")
# 5. Multicolinearity
performance::check_collinearity(model_interaction)
# Transform the variables when running the model and check assumptions again
model_interaction_transformed <- lm(`Life Exp` ~ log(Income) * Region, data = df_states)
summary(model_interaction_transformed)
# Transform the variables when running the model and check assumptions again
model_interaction_transformed <- lm(`Life Exp` ~ log(Income) * Region, data = df_states)
summary(model_interaction_transformed)
check_model(model_interaction_transformed)
# Transform the variables when running the model and check assumptions again
model_interaction_transformed <- lm(`Life Exp` ~ log(Income) * Region, data = df_states)
summary(model_interaction_transformed)
check_model(model_interaction_transformed, check = "linearity")
check_model(model_interaction_transformed, check = "homogeneity")
check_model(model_interaction_transformed, check = "normality")
check_model(model_interaction_transformed, check = "outliers")
performance::check_collinearity(model_interaction_transformed)
anova(model_income, model_income_region, model_interaction)
anova(model_income, model_income_region, model_interaction)
knitr::opts_chunk$set(echo = TRUE)
# Install pacman first (only once):
install.packages("pacman")
# Load and install packages:
pacman::p_load(ggplot2, dplyr, tidyr, broom, performance, see)
df_states <- as.data.frame(state.x77)
df_states$Region <- state.region
head(df_states)
ggplot(df_states, aes(x = Income, y = `Life Exp`)) +
geom_point() +
theme_minimal() +
labs(title = "Relationship between Income and Illiteracy", x = "Income (per person in 1974)", y = "Life expectancy (in years)")
model_income <- lm(`Life Exp` ~ Income, data = df_states)
summary(model_income)
model_income_region <- lm(`Life Exp` ~ Income + Region, data = df_states)
summary(model_income_region)
model_interaction <- lm(`Life Exp` ~ Income * Region, data = df_states)
summary(model_interaction)
# Plot the interaction
ggplot(df_states, aes(x = Income, y = `Life Exp`, color = Region)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE) +
theme_minimal()
# 1. Linearity
check_model(model_interaction, check = "linearity")
# 2. Homoscedasticity (constant variance)
check_model(model_interaction, check = "homogeneity")
# 3. Normality of residuals
check_model(model_interaction, check = "normality")
# 4. Outliers / influential points
check_model(model_interaction, check = "outliers")
install.packages("pacman")
# 5. Multicolinearity
performance::check_collinearity(model_interaction)
# Transform the variables when running the model and check assumptions again
model_interaction_transformed <- lm(`Life Exp` ~ log(Income) * Region, data = df_states)
summary(model_interaction_transformed)
check_model(model_interaction_transformed, check = "linearity")
check_model(model_interaction_transformed, check = "homogeneity")
check_model(model_interaction_transformed, check = "normality")
check_model(model_interaction_transformed, check = "outliers")
performance::check_collinearity(model_interaction_transformed)
anova(model_income, model_income_region, model_interaction)
# Change your_chosen_model with the actual model name
ggplot(your_chosen_model, aes(x = Income, y = `Life Exp`, color = Region)) +
geom_point() +
geom_line(aes(y = predict(your_chosen_model)), size = 1) +
theme_minimal()
# Change your_chosen_model with the actual model name
your_chosen_model <- model_income_region
ggplot(your_chosen_model, aes(x = Income, y = `Life Exp`, color = Region)) +
geom_point() +
geom_line(aes(y = predict(your_chosen_model)), size = 1) +
theme_minimal()
summary(your_chosen_model)
# Change your_chosen_model with the actual model name
your_chosen_model <- model_income_regions
anova(model_income, model_income_region, model_interaction)
# Change your_chosen_model with the actual model name
your_chosen_model <- model_income_regions
# Change your_chosen_model with the actual model name
your_chosen_model <- model_income_region
ggplot(your_chosen_model, aes(x = Income, y = `Life Exp`, color = Region)) +
geom_point() +
geom_line(aes(y = predict(your_chosen_model)), linewidth = 1) +
theme_minimal()
summary(your_chosen_model)
